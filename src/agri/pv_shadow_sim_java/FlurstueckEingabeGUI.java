/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package agri.pv_shadow_sim_java;


import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import javax.swing.JOptionPane;
import javax.swing.text.NumberFormatter;
import org.json.JSONArray;
import org.json.JSONObject;
import org.locationtech.jts.geom.*;

/**
 * Die Klasse {@code FlurstueckEingabeGUI} repräsentiert das GUI-Fenster zur Eingabe
 * und Auswahl eines Flurstücks. Der Benutzer kann ein Flurstück entweder über
 * seine Nummer (Zähler/Nenner) oder über geografische Koordinaten auswählen.
 * Die Daten werden über eine ALKIS-API abgerufen und im {@code AgriPVData}-Objekt gespeichert.
 *
 * @author roesc
 */
public class FlurstueckEingabeGUI extends javax.swing.JFrame {

    private AgriPVData data; // Das Datenobjekt, das die Flurstücksinformationen speichert
    private KonfigurationGUI kGUI; // Referenz zur KonfigurationGUI, um Updates zu senden
    private ALKISApiClient aAC; // Client für die Kommunikation mit der ALKIS-API
    private NumberFormatter zaehlerFormatter; // Formatter für den Flurstückzähler
    private NumberFormatter gradFormatter; // Formatter für Grad-Werte (Koordinaten)
    private NumberFormatter minFormatter; // Formatter für Minuten-Werte (Koordinaten)
    private NumberFormatter secFormat; // Formatter für Sekunden-Werte (Koordinaten)
    private NumberFormatter deziFormatter; // Formatter für Dezimalgrad-Koordinaten
    private int counter; // Zähler für Debugging-Zwecke (z.B. für den Import-Button)
    
    /**
     * Erstellt ein neues Formular FlurstueckEingabeGUI.
     * Verwendet Standardinstanzen von AgriPVData und KonfigurationGUI.
     */
    public FlurstueckEingabeGUI() {
        this(new AgriPVData(), new KonfigurationGUI());
    }
    
    /**
     * Erstellt ein neues Formular FlurstueckEingabeGUI mit den gegebenen Datenobjekten.
     *
     * @param data Das {@code AgriPVData}-Objekt, das die Flurstücksinformationen speichern wird.
     * @param kGUI Die Referenz zur {@code KonfigurationGUI}, um Rückmeldungen zu geben.
     */
    public FlurstueckEingabeGUI(AgriPVData data, KonfigurationGUI kGUI){
        this.data = data;
        this.kGUI = kGUI;
        init(); // Initialisiert Formatter und API-Client
        initComponents(); // Initialisiert die Swing-Komponenten
        updateMarkings(); // Aktualisiert die Gemarkungs-Dropdown-Liste
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jbtnUebernehmen = new javax.swing.JButton();
        jbtnAbbrechen = new javax.swing.JButton();
        jtbdpnFlurKoord = new javax.swing.JTabbedPane();
        jpnlFlurstueckEingabe = new javax.swing.JPanel();
        jlblFlurstuecknummer = new javax.swing.JLabel();
        jfrmttxtfldFlurstueckzahler = new javax.swing.JFormattedTextField(zaehlerFormatter);
        jLabel1 = new javax.swing.JLabel();
        jfrmttxtfldFlurstuecknenner = new javax.swing.JFormattedTextField(zaehlerFormatter);
        jtbdpnKoordinatenEingabe = new javax.swing.JTabbedPane();
        jpnlGMSEingabe = new javax.swing.JPanel();
        jtxtfldNGrad = new javax.swing.JFormattedTextField(gradFormatter);
        jlblN1 = new javax.swing.JLabel();
        jtxtfldNMinuten = new javax.swing.JFormattedTextField(minFormatter);
        jlblN2 = new javax.swing.JLabel();
        jtxtfldNSekunden = new javax.swing.JFormattedTextField(secFormat);
        jlblN3 = new javax.swing.JLabel();
        jtxtfldEGrad = new javax.swing.JFormattedTextField(gradFormatter);
        jlblE1 = new javax.swing.JLabel();
        jtxtfldEMinuten = new javax.swing.JFormattedTextField(minFormatter);
        jlblE2 = new javax.swing.JLabel();
        jtxtfldESekunden = new javax.swing.JFormattedTextField(secFormat);
        jlblE3 = new javax.swing.JLabel();
        jpnlDGEingabe = new javax.swing.JPanel();
        jtxtfldDGNorthing = new javax.swing.JFormattedTextField(deziFormatter);
        jtxtfldDGEasting = new javax.swing.JFormattedTextField(deziFormatter);
        jlblDGEasting = new javax.swing.JLabel();
        jlblDGNorthing = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jlblGemeinde = new javax.swing.JLabel();
        jcmbbxGemeinde = new javax.swing.JComboBox<>();
        jbtnAPImakeImport = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Auswahl des Flurstücks");

        jbtnUebernehmen.setText("Übernehmen");
        jbtnUebernehmen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtnUebernehmenActionPerformed(evt);
            }
        });
        jbtnUebernehmen.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jbtnUebernehmenKeyPressed(evt);
            }
        });

        jbtnAbbrechen.setText("Abbrechen");
        jbtnAbbrechen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtnAbbrechenActionPerformed(evt);
            }
        });
        jbtnAbbrechen.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jbtnAbbrechenKeyPressed(evt);
            }
        });

        jtbdpnFlurKoord.setForeground(new java.awt.Color(220, 214, 204));

        jlblFlurstuecknummer.setText("Flurstückzähler");

        jfrmttxtfldFlurstueckzahler.setColumns(10);
        jfrmttxtfldFlurstueckzahler.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jfrmttxtfldFlurstueckzahlerFocusGained(evt);
            }
        });
        jfrmttxtfldFlurstueckzahler.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jfrmttxtfldFlurstueckzahlerKeyPressed(evt);
            }
        });

        jLabel1.setText("Flurstücksnenner");

        jfrmttxtfldFlurstuecknenner.setColumns(10);
        jfrmttxtfldFlurstuecknenner.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jfrmttxtfldFlurstuecknennerFocusGained(evt);
            }
        });
        jfrmttxtfldFlurstuecknenner.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jfrmttxtfldFlurstuecknennerKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout jpnlFlurstueckEingabeLayout = new javax.swing.GroupLayout(jpnlFlurstueckEingabe);
        jpnlFlurstueckEingabe.setLayout(jpnlFlurstueckEingabeLayout);
        jpnlFlurstueckEingabeLayout.setHorizontalGroup(
            jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlFlurstueckEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jfrmttxtfldFlurstueckzahler, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jlblFlurstuecknummer, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jfrmttxtfldFlurstuecknenner, javax.swing.GroupLayout.DEFAULT_SIZE, 189, Short.MAX_VALUE))
                .addContainerGap(66, Short.MAX_VALUE))
        );
        jpnlFlurstueckEingabeLayout.setVerticalGroup(
            jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlFlurstueckEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jlblFlurstuecknummer)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlFlurstueckEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jfrmttxtfldFlurstueckzahler, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jfrmttxtfldFlurstuecknenner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(63, Short.MAX_VALUE))
        );

        jtbdpnFlurKoord.addTab("Flurstücknummer", jpnlFlurstueckEingabe);

        jtxtfldNGrad.setColumns(3);
        jtxtfldNGrad.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldNGradFocusGained(evt);
            }
        });
        jtxtfldNGrad.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldNGradKeyPressed(evt);
            }
        });

        jlblN1.setText("°");

        jtxtfldNMinuten.setColumns(2);
        jtxtfldNMinuten.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldNMinutenFocusGained(evt);
            }
        });
        jtxtfldNMinuten.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldNMinutenKeyPressed(evt);
            }
        });

        jlblN2.setText("'");

        jtxtfldNSekunden.setColumns(5);
        jtxtfldNSekunden.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldNSekundenFocusGained(evt);
            }
        });
        jtxtfldNSekunden.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldNSekundenKeyPressed(evt);
            }
        });

        jlblN3.setText("'' N");

        jtxtfldEGrad.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldEGradFocusGained(evt);
            }
        });
        jtxtfldEGrad.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldEGradKeyPressed(evt);
            }
        });

        jlblE1.setText("°");

        jtxtfldEMinuten.setColumns(2);
        jtxtfldEMinuten.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldEMinutenFocusGained(evt);
            }
        });
        jtxtfldEMinuten.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldEMinutenKeyPressed(evt);
            }
        });

        jlblE2.setText("'");

        jtxtfldESekunden.setColumns(5);
        jtxtfldESekunden.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldESekundenFocusGained(evt);
            }
        });
        jtxtfldESekunden.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldESekundenKeyPressed(evt);
            }
        });

        jlblE3.setText("'' E");

        javax.swing.GroupLayout jpnlGMSEingabeLayout = new javax.swing.GroupLayout(jpnlGMSEingabe);
        jpnlGMSEingabe.setLayout(jpnlGMSEingabeLayout);
        jpnlGMSEingabeLayout.setHorizontalGroup(
            jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlGMSEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jtxtfldEGrad, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtxtfldNGrad, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jlblE1, javax.swing.GroupLayout.DEFAULT_SIZE, 13, Short.MAX_VALUE)
                    .addComponent(jlblN1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jpnlGMSEingabeLayout.createSequentialGroup()
                        .addComponent(jtxtfldEMinuten, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jlblE2, javax.swing.GroupLayout.DEFAULT_SIZE, 11, Short.MAX_VALUE))
                    .addGroup(jpnlGMSEingabeLayout.createSequentialGroup()
                        .addComponent(jtxtfldNMinuten, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jlblN2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jtxtfldNSekunden, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtxtfldESekunden, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jlblN3)
                    .addComponent(jlblE3, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(196, 196, 196))
        );
        jpnlGMSEingabeLayout.setVerticalGroup(
            jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlGMSEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jtxtfldNGrad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblN1)
                    .addComponent(jlblN2)
                    .addComponent(jtxtfldNSekunden, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblN3)
                    .addComponent(jtxtfldNMinuten, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jpnlGMSEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jtxtfldEGrad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblE1)
                    .addComponent(jlblE2)
                    .addComponent(jtxtfldESekunden, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblE3)
                    .addComponent(jtxtfldEMinuten, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(12, Short.MAX_VALUE))
        );

        jtbdpnKoordinatenEingabe.addTab("GMS ", jpnlGMSEingabe);

        jtxtfldDGNorthing.setColumns(12);
        jtxtfldDGNorthing.setToolTipText("");
        jtxtfldDGNorthing.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldDGNorthingFocusGained(evt);
            }
        });
        jtxtfldDGNorthing.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldDGNorthingKeyPressed(evt);
            }
        });

        jtxtfldDGEasting.setColumns(12);
        jtxtfldDGEasting.setToolTipText("");
        jtxtfldDGEasting.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jtxtfldDGEastingFocusGained(evt);
            }
        });
        jtxtfldDGEasting.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jtxtfldDGEastingKeyPressed(evt);
            }
        });

        jlblDGEasting.setText("Längengrad");
        jlblDGEasting.setToolTipText("");

        jlblDGNorthing.setText("Breitengrad");
        jlblDGNorthing.setToolTipText("");

        javax.swing.GroupLayout jpnlDGEingabeLayout = new javax.swing.GroupLayout(jpnlDGEingabe);
        jpnlDGEingabe.setLayout(jpnlDGEingabeLayout);
        jpnlDGEingabeLayout.setHorizontalGroup(
            jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlDGEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jtxtfldDGNorthing)
                    .addComponent(jtxtfldDGEasting, javax.swing.GroupLayout.DEFAULT_SIZE, 187, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jlblDGNorthing, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblDGEasting))
                .addContainerGap(141, Short.MAX_VALUE))
        );
        jpnlDGEingabeLayout.setVerticalGroup(
            jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jpnlDGEingabeLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jtxtfldDGNorthing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblDGNorthing))
                .addGap(18, 18, 18)
                .addGroup(jpnlDGEingabeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jtxtfldDGEasting, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jlblDGEasting))
                .addContainerGap(12, Short.MAX_VALUE))
        );

        jtbdpnKoordinatenEingabe.addTab("Dezimalgrad", jpnlDGEingabe);

        jtbdpnFlurKoord.addTab("Koordinaten", jtbdpnKoordinatenEingabe);

        jlblGemeinde.setText("Gemeinde");

        jcmbbxGemeinde.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Gemeindename" }));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jlblGemeinde, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jcmbbxGemeinde, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jlblGemeinde)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jcmbbxGemeinde, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jbtnAPImakeImport.setText(" ");
        jbtnAPImakeImport.setVisible(false);
        jbtnAPImakeImport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtnAPImakeImportActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jtbdpnFlurKoord)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jbtnAPImakeImport)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jbtnAbbrechen)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jbtnUebernehmen)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jtbdpnFlurKoord, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jbtnUebernehmen)
                    .addComponent(jbtnAbbrechen)
                    .addComponent(jbtnAPImakeImport))
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Initialisiert die NumberFormatter für die verschiedenen Eingabefelder.
     * Dies stellt sicher, dass die Benutzereingaben korrekt formatiert und validiert werden.
     */
    private void init(){
        // Initialisiert den ALKIS API Client mit der Basis-URL des lokalen Servers.
        this.aAC = new ALKISApiClient("http://localhost:5000/api/Flurstueck"); 
        
        // Formatter für ganze Zahlen (z.B. Flurstückzähler/nenner)
        NumberFormat format = NumberFormat.getIntegerInstance();
        format.setGroupingUsed(false); // Keine Tausenderpunkte verwenden

        zaehlerFormatter = new NumberFormatter(format);
        zaehlerFormatter.setValueClass(Integer.class);
        zaehlerFormatter.setAllowsInvalid(false); // Ungültige Eingaben nicht zulassen
        zaehlerFormatter.setMinimum(0); // Nur positive Zahlen größer 0 zulassen

        // Formatter für Grad-Werte (GMS)
        gradFormatter = new NumberFormatter(format);
        gradFormatter.setValueClass(Integer.class);
        gradFormatter.setAllowsInvalid(false);
        gradFormatter.setMinimum(-180); // Grad kann 0 sein
        gradFormatter.setMaximum(180); // Maximal 180 Grad

        // Formatter für Minuten-Werte (GMS)
        minFormatter = new NumberFormatter(format);
        minFormatter.setValueClass(Integer.class);
        minFormatter.setAllowsInvalid(false);
        minFormatter.setMinimum(0);
        minFormatter.setMaximum(59); // Minuten gehen von 0 bis 59

        // Formatter für Sekunden-Werte (GMS), erlaubt Dezimalstellen
        NumberFormat secFormatRaw = NumberFormat.getInstance();
        secFormatRaw.setMinimumFractionDigits(2); // Mindestens 2 Dezimalstellen
        secFormatRaw.setMaximumFractionDigits(5); // Maximal 5 Dezimalstellen
        secFormatRaw.setGroupingUsed(false);

        secFormat = new NumberFormatter(secFormatRaw);
        secFormat.setValueClass(Double.class);
        secFormat.setAllowsInvalid(false);
        secFormat.setMinimum(0.0);
        secFormat.setMaximum(59.99999); // Sekunden gehen von 0.0 bis 59.99999

        // Formatter für Dezimalgrad-Werte (UTM/Dezimalgrad), erlaubt Dezimalstellen
        NumberFormat deziFormatRaw = NumberFormat.getInstance();
        deziFormatRaw.setMinimumFractionDigits(6); // Mindestens 6 Dezimalstellen für Genauigkeit
        deziFormatRaw.setMaximumFractionDigits(9); // Maximal 9 Dezimalstellen
        deziFormatRaw.setGroupingUsed(false);

        deziFormatter = new NumberFormatter(deziFormatRaw);
        deziFormatter.setValueClass(Double.class);
        deziFormatter.setAllowsInvalid(false);
        // Setzen Sie realistische Min/Max-Werte für Längen- und Breitengrade:
        // Breitengrad von -90 bis +90
        //deziFormatter.setMinimum(-90.0); 
        //deziFormatter.setMaximum(90.0);
        // Für Längengrad:
        deziFormatter.setMinimum(-180.0);
        deziFormatter.setMaximum(180.0);
        
        counter = 0; // Initialisiert den Debug-Zähler
    }
    
    /**
     * Behandelt das ActionEvent des "Abbrechen"-Buttons.
     * Ruft die Methode {@code jbtnAbbrechenPressed()} auf, um das Fenster zu schließen.
     * @param evt Das ActionEvent, das durch das Klicken des Buttons ausgelöst wird.
     */
    private void jbtnAbbrechenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtnAbbrechenActionPerformed
        jbtnAbbrechenPressed();
    }//GEN-LAST:event_jbtnAbbrechenActionPerformed

    /**
     * Behandelt das ActionEvent des "Übernehmen"-Buttons.
     * Ruft die Methode {@code jbtnUebernehmenPressed()} auf, um die Flurstücksdaten zu verarbeiten.
     * @param evt Das ActionEvent, das durch das Klicken des Buttons ausgelöst wird.
     */
    private void jbtnUebernehmenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtnUebernehmenActionPerformed
        jbtnUebernehmenPressed();
    }//GEN-LAST:event_jbtnUebernehmenActionPerformed

    /**
     * Wählt den gesamten Text im Feld für Nord-Grad aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldNGradFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldNGradFocusGained
        jtxtfldNGrad.selectAll();
    }//GEN-LAST:event_jtxtfldNGradFocusGained

    /**
     * Wählt den gesamten Text im Feld für Nord-Minuten aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldNMinutenFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldNMinutenFocusGained
        jtxtfldNMinuten.selectAll();
    }//GEN-LAST:event_jtxtfldNMinutenFocusGained

    /**
     * Wählt den gesamten Text im Feld für Nord-Sekunden aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldNSekundenFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldNSekundenFocusGained
        jtxtfldNSekunden.selectAll();
    }//GEN-LAST:event_jtxtfldNSekundenFocusGained

    /**
     * Wählt den gesamten Text im Feld für Ost-Grad aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldEGradFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldEGradFocusGained
        jtxtfldEGrad.selectAll();
    }//GEN-LAST:event_jtxtfldEGradFocusGained

    /**
     * Wählt den gesamten Text im Feld für Ost-Minuten aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldEMinutenFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldEMinutenFocusGained
        jtxtfldEMinuten.selectAll();
    }//GEN-LAST:event_jtxtfldEMinutenFocusGained

    /**
     * Wählt den gesamten Text im Feld für Ost-Sekunden aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldESekundenFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldESekundenFocusGained
        jtxtfldESekunden.selectAll();
    }//GEN-LAST:event_jtxtfldESekundenFocusGained

    /**
     * Wählt den gesamten Text im Feld für Dezimalgrad Northing (Breitengrad) aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldDGNorthingFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldDGNorthingFocusGained
        jtxtfldDGNorthing.selectAll();
    }//GEN-LAST:event_jtxtfldDGNorthingFocusGained

    /**
     * Wählt den gesamten Text im Feld für Dezimalgrad Easting (Längengrad) aus, wenn es den Fokus erhält.
     * Erhöht einen internen Zähler für Debugging-Zwecke und macht einen versteckten Button sichtbar.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jtxtfldDGEastingFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtxtfldDGEastingFocusGained
        jtxtfldDGEasting.selectAll();
        counter++;
        if(counter > 10){ // Nach 10 Fokus-Ereignissen wird der Import-Button sichtbar
            jbtnAPImakeImport.setVisible(true);
        }
    }//GEN-LAST:event_jtxtfldDGEastingFocusGained

    /**
     * Behandelt den Tastendruck im Feld für Nord-Grad.
     * Bei "Enter" wird der Fokus auf das Feld für Nord-Minuten verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldNGradKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldNGradKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldNMinuten.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldNGradKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Nord-Minuten.
     * Bei "Enter" wird der Fokus auf das Feld für Nord-Sekunden verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldNMinutenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldNMinutenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldNSekunden.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldNMinutenKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Nord-Sekunden.
     * Bei "Enter" wird der Fokus auf das Feld für Ost-Grad verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldNSekundenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldNSekundenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldEGrad.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldNSekundenKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Ost-Grad.
     * Bei "Enter" wird der Fokus auf das Feld für Ost-Minuten verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldEGradKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldEGradKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldEMinuten.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldEGradKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Ost-Minuten.
     * Bei "Enter" wird der Fokus auf das Feld für Ost-Sekunden verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldEMinutenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldEMinutenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldESekunden.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldEMinutenKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Ost-Sekunden.
     * Bei "Enter" wird der Fokus auf den "Übernehmen"-Button verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldESekundenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldESekundenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jbtnUebernehmen.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldESekundenKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Dezimalgrad Northing (Breitengrad).
     * Bei "Enter" wird der Fokus auf das Feld für Dezimalgrad Easting (Längengrad) verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldDGNorthingKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldDGNorthingKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jtxtfldDGEasting.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldDGNorthingKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für Dezimalgrad Easting (Längengrad).
     * Bei "Enter" wird der Fokus auf den "Übernehmen"-Button verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jtxtfldDGEastingKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtxtfldDGEastingKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jbtnUebernehmen.grabFocus();
        }
    }//GEN-LAST:event_jtxtfldDGEastingKeyPressed

    /**
     * Behandelt den Tastendruck auf dem "Abbrechen"-Button.
     * Bei "Enter" wird die Methode zum Abbrechen des Dialogs aufgerufen.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jbtnAbbrechenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jbtnAbbrechenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jbtnAbbrechenPressed();
        }
    }//GEN-LAST:event_jbtnAbbrechenKeyPressed

    /**
     * Behandelt den Tastendruck auf dem "Übernehmen"-Button.
     * Bei "Enter" wird die Methode zum Übernehmen der Eingabe aufgerufen.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jbtnUebernehmenKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jbtnUebernehmenKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jbtnUebernehmenPressed();
        }
    }//GEN-LAST:event_jbtnUebernehmenKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für den Flurstückzähler.
     * Bei "Enter" wird der Fokus auf das Feld für den Flurstücksnenner verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jfrmttxtfldFlurstueckzahlerKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jfrmttxtfldFlurstueckzahlerKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jfrmttxtfldFlurstuecknenner.grabFocus();
        }
    }//GEN-LAST:event_jfrmttxtfldFlurstueckzahlerKeyPressed

    /**
     * Behandelt den Tastendruck im Feld für den Flurstücksnenner.
     * Bei "Enter" wird der Fokus auf den "Übernehmen"-Button verschoben.
     * @param evt Das KeyEvent, das durch einen Tastendruck ausgelöst wird.
     */
    private void jfrmttxtfldFlurstuecknennerKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jfrmttxtfldFlurstuecknennerKeyPressed
        if (evt.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER){
            jbtnUebernehmen.grabFocus();
        }
    }//GEN-LAST:event_jfrmttxtfldFlurstuecknennerKeyPressed

    
    /**
     * Behandelt das ActionEvent des versteckten Import-Buttons.
     * Ruft die asynchrone Import-Methode des ALKISApiClient auf und verbirgt den Button wieder.
     * @param evt Das ActionEvent, das durch das Klicken des Buttons ausgelöst wird.
     */
    private void jbtnAPImakeImportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtnAPImakeImportActionPerformed
        try {
            aAC.makeImportAsync(); // Startet den Importvorgang asynchron
            jbtnAPImakeImport.setVisible(false); // Versteckt den Button nach dem Klick
        } catch (Exception ex) {
            ex.printStackTrace(); // Gibt Fehler auf der Konsole aus
        }
    }//GEN-LAST:event_jbtnAPImakeImportActionPerformed

    /**
     * Wählt den gesamten Text im Feld für Flurstückzahler aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jfrmttxtfldFlurstueckzahlerFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jfrmttxtfldFlurstueckzahlerFocusGained
        jfrmttxtfldFlurstueckzahler.selectAll();
    }//GEN-LAST:event_jfrmttxtfldFlurstueckzahlerFocusGained

    /**
     * Wählt den gesamten Text im Feld für Flurstücknenner aus, wenn es den Fokus erhält.
     * @param evt Das FocusEvent, das durch das Erhalten des Fokus ausgelöst wird.
     */
    private void jfrmttxtfldFlurstuecknennerFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jfrmttxtfldFlurstuecknennerFocusGained
        jfrmttxtfldFlurstuecknenner.selectAll();
    }//GEN-LAST:event_jfrmttxtfldFlurstuecknennerFocusGained

    /**
     * Hauptmethode zum Starten der Anwendung.
     * Erstellt und zeigt das FlurstueckEingabeGUI-Fenster an.
     *
     * @param args Die Kommandozeilenargumente (nicht verwendet).
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FlurstueckEingabeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FlurstueckEingabeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FlurstueckEingabeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FlurstueckEingabeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FlurstueckEingabeGUI().setVisible(true);
            }
        });
    }
    
    /**
     * Schließt das aktuelle Fenster.
     */
    private void jbtnAbbrechenPressed(){
        this.dispose();
    }
    
    /**
     * Verarbeitet die Benutzereingaben und ruft die ALKIS-API auf, um die Flurstücksdaten abzurufen.
     * Aktualisiert das {@code AgriPVData}-Objekt mit den abgerufenen Informationen
     * und benachrichtigt die {@code KonfigurationGUI} über die Auswahl des Flurstücks.
     * Zeigt eine Warnmeldung an, wenn kein passendes Flurstück gefunden wurde.
     */
    private void jbtnUebernehmenPressed(){
        try {
            String testjson;
            // Prüft, welcher Tab ausgewählt ist (Flurstücknummer oder Koordinaten)
            if(jtbdpnFlurKoord.getSelectedIndex()==0){ // Flurstücknummer-Tab
                // Prüft ob Felder leer sind und handelt dem entsprechend
                if(jfrmttxtfldFlurstueckzahler.getText().strip().equals("")){
                    jfrmttxtfldFlurstueckzahler.grabFocus();
                    return;
                } else if(jfrmttxtfldFlurstuecknenner.getText().strip().equals("")){
                    jfrmttxtfldFlurstuecknenner.setText("0");
                }
                
                // Ruft die API mit Zähler, Nenner und ausgewählter Gemarkung auf
                testjson = aAC.getByCounterNominator(jfrmttxtfldFlurstueckzahler.getText(), jfrmttxtfldFlurstuecknenner.getText(), jcmbbxGemeinde.getSelectedItem().toString());
                JSONArray tmp = new JSONArray(testjson);
                testjson = tmp.getJSONObject(0).toString(); // Nimmt das erste Ergebnis, falls mehrere gefunden werden
            
            }else if(jtbdpnKoordinatenEingabe.getSelectedIndex()==0){ // Koordinaten-Tab (Grad/Min/Sek)
                // Prüft ob Felder leer sind und handelt dem entsprechend
                if(jtxtfldNGrad.getText().strip().equals("") || jtxtfldNMinuten.getText().strip().equals("") || jtxtfldNSekunden.getText().strip().equals("")){
                    jtxtfldNGrad.grabFocus();
                    return;
                } 
                if(jtxtfldEGrad.getText().strip().equals("") || jtxtfldEMinuten.getText().strip().equals("") || jtxtfldESekunden.getText().strip().equals("")){
                    jtxtfldEGrad.grabFocus();
                    return;
                }
                
                // Konvertiert Grad/Min/Sek in Dezimalgrad und ruft die API auf
                double latitude = data.dmsToDecimal(Integer.parseInt(jtxtfldNGrad.getText().strip()), Integer.parseInt(jtxtfldNMinuten.getText().strip()), Double.parseDouble(jtxtfldNSekunden.getText().strip().replace(",", ".")));
                double longitude = data.dmsToDecimal(Integer.parseInt(jtxtfldEGrad.getText().strip()), Integer.parseInt(jtxtfldEMinuten.getText().strip()), Double.parseDouble(jtxtfldESekunden.getText().strip().replace(",", ".")));
                testjson = aAC.getByCoordinate(latitude, longitude, jcmbbxGemeinde.getSelectedItem().toString());
            
            } else { // Dezimalgrad-Tab
                // Prüft ob Felder leer sind und handelt dem entsprechend
                if(jtxtfldDGNorthing.getText().strip().equals("")){
                    jtxtfldNGrad.grabFocus();
                    return;
                } 
                if(jtxtfldDGEasting.getText().strip().equals("")){
                    jtxtfldEGrad.grabFocus();
                    return;
                }
                testjson = aAC.getByCoordinate(Double.parseDouble(jtxtfldDGNorthing.getText().strip().replace(",", ".")), Double.parseDouble(jtxtfldDGEasting.getText().strip().replace(",", ".")), jcmbbxGemeinde.getSelectedItem().toString());
            }
            
            // Prüft, ob die API-Antwort anzeigt, dass kein Flurstück gefunden wurde.
            if(testjson.contains("Kein passendes Flurst")){
                JOptionPane.showMessageDialog(
                    null,
                    "Unter den angegebenen Kriterien konnte kein Flurstück gefunden werden.",
                    "Hinweis: Kein Flurstück gefunden",
                    JOptionPane.WARNING_MESSAGE
                );
                return; // Beendet die Methode, da kein Flurstück gefunden wurde.
            }
            
            // Parsen der JSON-Antwort
            JSONObject gesamtJSON = new JSONObject(testjson);
            
            // Extrahieren der Flurstücksdaten aus dem JSON und Speichern in data
            String[] gmn = gesamtJSON.getString("dateiname").split("_");
            data.gemeindename = gmn[2] + ((gmn.length > 4) ? gmn[3] : "");
            // Setzt den Gemeindenamen, berücksichtigt, ob der Dateiname mehrere Teile enthält
            data.flurstueckszaehler = gesamtJSON.getInt("zaehler"); // Setzt den Flurstückzähler
            data.flurstuecksnenner = gesamtJSON.getInt("nenner"); // Setzt den Flurstücksnenner
            data.amtFlaeche = gesamtJSON.getInt("amtlicheFlaeche"); // Setzt die amtliche Fläche

            JSONArray koordinatenJSON;
            // Prüft, ob Koordinaten als Array oder als WKT-String vorliegen
            if (gesamtJSON.isNull("koordinaten")){                
                String tmp = gesamtJSON.getString("wkt");
                // Konvertiert WKT-String in ein JSON-Array-Format, das geparst werden kann
                // Ersetzt "POLYGON ((" mit "{"koordinaten":[" und "))" mit "]}".
                // Ersetzt "x y" Paare mit "[x,y]" und entfernt Leerzeichen.
                tmp = tmp.replace("POLYGON ((", "{\"koordinaten\":[").replace("))", "]}").replaceAll("(\\d+(?:\\.\\d+)?)\\s+(\\d+(?:\\.\\d+)?)", "[$1,$2]").replaceAll("\\s+", "");
                JSONObject tmpJSON = new JSONObject(tmp);
                koordinatenJSON = tmpJSON.getJSONArray("koordinaten");
            } else {
                koordinatenJSON = gesamtJSON.getJSONArray("koordinaten");
            }
            data.points = koordinatenJSON.length(); // Anzahl der Koordinatenpunkte
            
            data.grundstuecksgrenze = new double[2][data.points]; // Initialisiert das Array für die Grundstücksgrenze
            data.mine = Double.MAX_VALUE; // Initialisiert min/max Werte für die Bounding Box
            data.minn = Double.MAX_VALUE;
            data.maxe = Double.MIN_VALUE;
            data.maxn = Double.MIN_VALUE;
            
            ArrayList<Coordinate> tmpList = new ArrayList<>(); // Temporäre Liste für JTS-Koordinaten
            
            // Iteriert durch die Koordinatenpunkte, speichert sie und aktualisiert die Bounding Box
            for (int i = 0; i < data.points; i++) {
                JSONArray punkte = koordinatenJSON.getJSONArray(i);
                double tmpX = Double.parseDouble(punkte.get(0).toString());
                double tmpY = Double.parseDouble(punkte.get(1).toString());
                data.grundstuecksgrenze[0][i] = tmpX; // Ost-Koordinate
                data.grundstuecksgrenze[1][i] = tmpY; // Nord-Koordinate
                
                tmpList.add(new Coordinate(tmpX, tmpY)); // Fügt JTS-Koordinate hinzu
                
                // Aktualisiert die minimale und maximale Ost/Nord-Koordinate (Bounding Box)
                if(data.grundstuecksgrenze[0][i] < data.mine){
                    data.mine = data.grundstuecksgrenze[0][i];
                }
                if(data.grundstuecksgrenze[1][i] < data.minn){
                    data.minn = data.grundstuecksgrenze[1][i];
                }
                if(data.grundstuecksgrenze[0][i] > data.maxe){
                    data.maxe = data.grundstuecksgrenze[0][i];
                }
                if(data.grundstuecksgrenze[1][i] > data.maxn){
                    data.maxn = data.grundstuecksgrenze[1][i];
                }
            }
            
            // Erstellt das JTS-Polygon für das Grundstück
            data.plotPolygon = createPolygon(tmpList);
            
            // Benachrichtigt die KonfigurationGUI, dass ein Flurstück ausgewählt wurde
            kGUI.flurstuckAusgewahlt();
            
            this.dispose(); // Schließt das aktuelle Fenster
        }catch(Exception e){
            e.printStackTrace(); // Gibt Fehlermeldungen auf der Konsole aus
            // Zeigt eine Fehlermeldung an den Benutzer
            JOptionPane.showMessageDialog(
                null,
                "Ein Fehler ist aufgetreten: " + e.getMessage() + "\nBitte überprüfen Sie Ihre Eingaben und die Verbindung zum ALKIS-API-Server.",
                "Fehler",
                JOptionPane.ERROR_MESSAGE
            );
            this.dispose(); // Schließt das Fenster auch bei Fehlern
        }        
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton jbtnAPImakeImport;
    private javax.swing.JButton jbtnAbbrechen;
    private javax.swing.JButton jbtnUebernehmen;
    private javax.swing.JComboBox<String> jcmbbxGemeinde;
    private javax.swing.JFormattedTextField jfrmttxtfldFlurstuecknenner;
    private javax.swing.JFormattedTextField jfrmttxtfldFlurstueckzahler;
    private javax.swing.JLabel jlblDGEasting;
    private javax.swing.JLabel jlblDGNorthing;
    private javax.swing.JLabel jlblE1;
    private javax.swing.JLabel jlblE2;
    private javax.swing.JLabel jlblE3;
    private javax.swing.JLabel jlblFlurstuecknummer;
    private javax.swing.JLabel jlblGemeinde;
    private javax.swing.JLabel jlblN1;
    private javax.swing.JLabel jlblN2;
    private javax.swing.JLabel jlblN3;
    private javax.swing.JPanel jpnlDGEingabe;
    private javax.swing.JPanel jpnlFlurstueckEingabe;
    private javax.swing.JPanel jpnlGMSEingabe;
    private javax.swing.JTabbedPane jtbdpnFlurKoord;
    private javax.swing.JTabbedPane jtbdpnKoordinatenEingabe;
    private javax.swing.JTextField jtxtfldDGEasting;
    private javax.swing.JTextField jtxtfldDGNorthing;
    private javax.swing.JTextField jtxtfldEGrad;
    private javax.swing.JTextField jtxtfldEMinuten;
    private javax.swing.JTextField jtxtfldESekunden;
    private javax.swing.JTextField jtxtfldNGrad;
    private javax.swing.JTextField jtxtfldNMinuten;
    private javax.swing.JTextField jtxtfldNSekunden;
    // End of variables declaration//GEN-END:variables

    /**
     * Erstellt ein JTS (Java Topology Suite) Polygon aus einer Liste von Koordinaten.
     * Stellt sicher, dass das Polygon geschlossen ist (erster und letzter Punkt sind identisch).
     *
     * @param coordinates Eine ArrayList von {@code Coordinate}-Objekten, die die Eckpunkte des Polygons bilden.
     * @return Ein {@code Polygon}-Objekt, das aus den gegebenen Koordinaten erstellt wurde.
     */
    public static Polygon createPolygon(ArrayList<Coordinate> coordinates) {
        GeometryFactory geometryFactory = new GeometryFactory();

        // Stelle sicher, dass das Polygon geschlossen ist (erster Punkt muss dem letzten entsprechen)
        if (!coordinates.get(0).equals2D(coordinates.get(coordinates.size() - 1))) {
            coordinates.add(coordinates.get(0));
        }

        // Konvertiere die ArrayList in ein Array von Koordinaten
        Coordinate[] coordArray = coordinates.toArray(new Coordinate[0]);
        // Erstelle einen LinearRing aus den Koordinaten (äußerer Ring des Polygons)
        LinearRing shell = geometryFactory.createLinearRing(coordArray);
        // Erstelle das Polygon aus dem LinearRing
        return geometryFactory.createPolygon(shell);
    }
    
    /**
     * Aktualisiert die Dropdown-Liste der Gemarkungen, indem sie Daten von der ALKIS-API abruft.
     * Bei erfolgreichem Login werden die Gemarkungen alphabetisch sortiert und in die ComboBox eingefügt.
     * Fängt {@code HttpHostConnectException} ab, um eine Meldung auszugeben, wenn der API-Server nicht erreichbar ist.
     */
    private void updateMarkings(){
        try{
            // Versucht, sich bei der ALKIS-API anzumelden
            if (aAC.login("ALKIS", "ALKIS")) { // Standard-Benutzername und -Passwort für die API
                ArrayList<String> markings = aAC.getMarkings(); // Ruft die Liste der Gemarkungen ab
                Collections.sort(markings); // Sortiert die Gemarkungen alphabetisch
                jcmbbxGemeinde.removeAllItems(); // Entfernt bestehende Einträge in der ComboBox
                // Fügt alle abgerufenen Gemarkungen der ComboBox hinzu
                for(String tmp : markings){
                    jcmbbxGemeinde.addItem(tmp);
                }
            } else {
                System.out.println("Login nicht erfolgreich!"); // Fehlermeldung bei fehlgeschlagenem Login
            }
        } catch(org.apache.http.conn.HttpHostConnectException e) {
            // Ignoriert die Fehlermeldung, wenn keine Verbindung zum Host aufgebaut werden kann
            // Dies ist oft der Fall, wenn der lokale API-Server nicht läuft
            // Fängt die spezifische Ausnahme für Verbindungsfehler ab.
            System.out.println("Fehler: Verbindung zur ALKIS-API konnte nicht hergestellt werden. Bitte stellen Sie sicher, dass der Server läuft.");
            JOptionPane.showMessageDialog(
                null,
                "Fehler: Verbindung zur ALKIS-API konnte nicht hergestellt werden.\nBitte stellen Sie sicher, dass der ALKISService.exe Server läuft.",
                "Verbindungsfehler",
                JOptionPane.ERROR_MESSAGE
            );
        } catch(Exception e){
            e.printStackTrace(); // Gibt andere unerwartete Fehler aus
        }        
    }
}
